AWSTemplateFormatVersion: 2010-09-09
Description: Functions Template.
  This creates Custom Resource Lambda Functions not broken out into a type-specific Template, but required during early
  Stack creation.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Stack Dependencies
        Parameters:
          - CodesStackName
          - LayersStackName
          - BucketsStackName
      - Label:
          default: Function Configuration
        Parameters:
          - BucketManagerLogRetention
          - RandomPasswordLogRetention
          - SecureParameterLogRetention
          - MessageLogRetention
          - PrivateIpAddressLogRetention
          - KeyPairLogRetention
          - AMINameLogRetention
          - AliasNameLogRetention
          - LogGroupNameLogRetention
          - HostNameLogRetention
          - DomainNameLogRetention
    ParameterLabels:
      CodesStackName:
        default: Codes Stack Name
      LayersStackName:
        default: Layers Stack Name
      BucketsStackName:
        default: Buckets Stack Name
      BucketManagerLogRetention:
        default: BucketManager Log Retention
      RandomPasswordLogRetention:
        default: RandomPassword Log Retention
      SecureParameterLogRetention:
        default: SecureParameter Log Retention
      MessageLogRetention:
        default: Message Log Retention
      PrivateIpAddressLogRetention:
        default: PrivateIpAddress Log Retention
      KeyPairLogRetention:
        default: KeyPair Log Retention
      AMINameLogRetention:
        default: AMIName Log Retention
      AliasNameLogRetention:
        default: AliasName Log Retention
      LogGroupNameLogRetention:
        default: LogGroupName Log Retention
      HostNameLogRetention:
        default: HostName Log Retention
      DomainNameLogRetention:
        default: DomainName Log Retention
Parameters:
  CodesStackName:
    Description: Name of the CloudFormation Stack containing Codes
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Codes
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  LayersStackName:
    Description: Name of the CloudFormation Stack containing Layers
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Layers
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  BucketsStackName:
    Description: Name of the CloudFormation Stack containing Buckets
    Type: String
    MinLength: 2
    MaxLength: 64
    Default: Buckets
    AllowedPattern: ^[A-Z][-a-zA-Z0-9]*$
    ConstraintDescription: must begin with an upper case letter and contain alphanumeric characters and dashes.
  BucketManagerLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the BucketManager Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  RandomPasswordLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the RandomPassword Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  SecureParameterLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the SecureParameter Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  MessageLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the Message Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  PrivateIpAddressLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the PrivateIpAddress Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  KeyPairLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the KeyPair Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  AMINameLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the AMIName Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  AliasNameLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the AliasName Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  LogGroupNameLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the LogGroupName Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  HostNameLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the HostName Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
  DomainNameLogRetention:
    Description: Number of days to retain CloudWatch Log Events for the DomainName Lambda Function
    Type: Number
    Default: 30
    AllowedValues:
      - 1
      - 3
      - 5
      - 7
      - 14
      - 30
      - 60
      - 90
    ConstraintDescription: must be 1, 3, 5, 7, 14, 30, 60 or 90.
Conditions:
  ConfigureGlobal: !Equals [ !Ref 'AWS::Region', us-east-1 ]
Resources:
  BucketManagerRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageBuckets
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:*
                Resource: '*'
  BucketManagerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/BucketManager
      RetentionInDays: !Ref BucketManagerLogRetention
  BucketManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BucketManager
      Description: A Lambda function that manages content in an S3 Bucket.
      Role: !GetAtt BucketManagerRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            s3: '2006-03-01'
          };

          const s3 = new AWS.S3();

          const emptyBucket = async (bucketName) => {
            const listParams = {
              Bucket: bucketName
            };
            let listData = {};
            do {
              listData = await s3.listObjectVersions(listParams).promise();
              //console.info(`- listObjectVersions Data:\n${JSON.stringify(listData, null, 2)}`);

              if (listData.Versions.length > 0) {
                const deleteParams = {
                  Bucket: bucketName,
                  Delete: {
                    Objects: listData.Versions.map(v => ({Key: v.Key, VersionId: v.VersionId}))
                  }
                };
                const deleting = deleteParams.Delete.Objects.length;
                const deleteData = await s3.deleteObjects(deleteParams).promise();
                const deleted = deleteData.Deleted.length;
                if (deleting == deleted) {
                  console.info(`- Deleted ${deleted} object versions`);
                }
                else {
                  console.info(`- deleteObjects Data:\n${JSON.stringify(deleteData, null, 2)}`);
                  throw new Error(`Could not delete ${deleting - deleted} object versions!`);
                }
              }

              if (listData.DeleteMarkers.length > 0) {
                const deleteParams = {
                  Bucket: bucketName,
                  Delete: {
                    Objects: listData.DeleteMarkers.map(dm => ({Key: dm.Key, VersionId: dm.VersionId}))
                  }
                };
                const deleting = deleteParams.Delete.Objects.length;
                const deleteData = await s3.deleteObjects(deleteParams).promise();
                const deleted = deleteData.Deleted.length;
                if (deleting == deleted) {
                  console.info(`- Deleted ${deleted} delete markers`);
                }
                else {
                  console.info(`- deleteObjects Data:\n${JSON.stringify(deleteData, null, 2)}`);
                  throw new Error(`Could not delete ${deleting - deleted} delete markers!`);
                }
              }

              if (listData.IsTruncated) {
                listParams.KeyMarker = listData.NextKeyMarker;
                listParams.VersionIdMarker = listData.NextVersionIdMarker;
              }
            } while (listData.IsTruncated);

            return;
          };

          const deleteBucket = async (bucketName) => {
            const params = {
              Bucket: bucketName
            };
            const data = await s3.deleteBucket(params).promise();
            //console.info(`- deleteBucket Data:\n${JSON.stringify(data, null, 2)}`);

            return;
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            let bucketName;
            let emptyAndDeleteBucket;

            try {
              bucketName = event.ResourceProperties.BucketName;
              if (! bucketName) {
                throw new Error(`BucketName missing: required Parameter`);
              }

              emptyAndDeleteBucket = /^(t(rue)?|y(es)?|1|on)$/i.test(event.ResourceProperties.EmptyAndDeleteBucket || 'True');
            }
            catch (err) {
              const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
              console.error(responseData.Error);
              await response.send(event, context, response.FAILED, responseData);
            }

            console.info(`BucketName: ${bucketName}`);
            console.info(`EmptyAndDeleteBucket: ${emptyAndDeleteBucket}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                await response.send(event, context, response.SUCCESS, {}, bucketName + '-manager');
                break;

              case 'Delete':
                try {
                  if (emptyAndDeleteBucket) {
                    console.info(`Calling: emptyBucket...`);
                    await emptyBucket(bucketName);

                    console.info(`Calling: deleteBucket...`);
                    await deleteBucket(bucketName);
                  }
                  await response.send(event, context, response.SUCCESS);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
            }
          };
    DependsOn: BucketManagerLogGroup
  RandomPasswordRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllowRandomPasswordGeneration
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetRandomPassword
                Resource: '*'
  RandomPasswordLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/RandomPassword
      RetentionInDays: !Ref RandomPasswordLogRetention
  RandomPasswordFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: RandomPassword
      Description: A Lambda function that generates a random password using the SecretsManager getRandomPassword method.
      Role: !GetAtt RandomPasswordRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            secretsmanager: '2017-10-17'
          };

          const secretsmanager = new AWS.SecretsManager();

          const parseBoolean = (value) => {
            const re=/^(t(rue)?|1|on|y(es)?)$/i;
            return re.test(value);
          };

          const response = {};
          response.SUCCESS = "SUCCESS";
          response.FAILED = "FAILED";
          response.send = function(event, context, responseStatus, responseData, physicalResourceId, noEcho) {
            var responseBody = JSON.stringify({
              Status: responseStatus,
              Reason: "See the details in CloudWatch Log Stream: " + context.logStreamName,
              PhysicalResourceId: physicalResourceId || context.logStreamName,
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              NoEcho: noEcho || false,
              Data: responseData
            });

            var https = require("https");
            var url = require("url");

            var parsedUrl = url.parse(event.ResponseURL);
            var options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: "PUT",
              headers: {
                "content-type": "",
                "content-length": responseBody.length
              }
            };

            var request = https.request(options, function(response) {
              console.log("Status code: " + response.statusCode);
              console.log("Status message: " + response.statusMessage);
              context.done();
            });

            request.on("error", function(error) {
              console.log("send(..) failed executing https.request(..): " + error);
              context.done();
            });

            request.write(responseBody);
            request.end();
          };

          exports.handler = (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: GetRandomPassword...`);
                if (event.ResourceProperties.PasswordLength) params.PasswordLength = Math.max(parseInt(event.ResourceProperties.PasswordLength, 10), 8);
                if (event.ResourceProperties.ExcludeUppercase) params.ExcludeUppercase = parseBoolean(event.ResourceProperties.ExcludeUppercase);
                if (event.ResourceProperties.ExcludeLowercase) params.ExcludeLowercase = parseBoolean(event.ResourceProperties.ExcludeLowercase);
                if (event.ResourceProperties.ExcludeNumbers) params.ExcludeNumbers = parseBoolean(event.ResourceProperties.ExcludeNumbers);
                if (event.ResourceProperties.ExcludePunctuation) params.ExcludePunctuation = parseBoolean(event.ResourceProperties.ExcludePunctuation);
                if (event.ResourceProperties.IncludeSpace) params.IncludeSpace = parseBoolean(event.ResourceProperties.IncludeSpace);
                if (event.ResourceProperties.RequireEachIncludedType) params.RequireEachIncludedType = parseBoolean(event.ResourceProperties.RequireEachIncludedType);
                if (event.ResourceProperties.ExcludeCharacters) params.ExcludeCharacters = event.ResourceProperties.ExcludeCharacters;
                secretsmanager.getRandomPassword(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const password = data.RandomPassword;
                    const s = Math.max(Math.min(Math.floor(password.length/4), 4), 1);
                    const m = password.length - 2 * s;
                    const obfuscatedPassword = password.replace(password.substr(s,m), '*'.repeat(m));
                    const responseData = {Password: password};
                    console.info(`RandomPassword: ${obfuscatedPassword} created`);
                    response.send(event, context, response.SUCCESS, responseData, obfuscatedPassword, true);
                  }
                });
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
            }
          };
    DependsOn: RandomPasswordLogGroup
  SecureParameterRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageSSMParameter
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                  - ssm:DeleteParameter
                  - kms:Encrypt
                Resource: '*'
  SecureParameterLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/SecureParameter
      RetentionInDays: !Ref SecureParameterLogRetention
  SecureParameterFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: SecureParameter
      Description: A Lambda function that handles an SSM SecureString Parameter as a CustomResource, as this parameter Type is not currently supported.
      Role: !GetAtt SecureParameterRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('./cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            ssm: '2014-11-06'
          };

          const ssm = new AWS.SSM();

          exports.handler = (event, context) => {
            const obfuscatedEvent = {};
            Object.assign(obfuscatedEvent, event);
            obfuscatedEvent.ResourceProperties = {};
            Object.assign(obfuscatedEvent.ResourceProperties, event.ResourceProperties);
            obfuscatedEvent.ResourceProperties.Value = event.ResourceProperties.Value.replace(/./g, '*');

            console.info(`Request Body:\n${JSON.stringify(obfuscatedEvent)}`);

            const name = event.ResourceProperties.Name || `${event.StackId.split(':')[5].split('/')[1]}-${event.LogicalResourceId}`;
            if (! name) {
              const responseData = {Error: `Error: Name missing`};
              console.error(responseData.Error);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const value = event.ResourceProperties.Value;
            if (! value && event.RequestType != 'Delete') {
              const responseData = {Error: `Error: Value missing`};
              console.error(responseData.Error);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const allowedPattern = event.ResourceProperties.AllowedPattern;
            const description = event.ResourceProperties.Description;

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: PutParameter...`);
                params = {
                  Name: name,
                  Type: 'SecureString',
                  Value: value,
                  Overwrite: (event.RequestType == 'Create') ? false : true
                };
                if (allowedPattern) params.AllowedPattern = allowedPattern;
                if (description) params.Description = description;
                ssm.putParameter(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    console.info(`SecureParameter: ${name} created`);
                    response.send(event, context, response.SUCCESS, null, name);
                  }
                });
                break;

              case 'Delete':
                console.info(`Calling: DeleteParameter...`);
                params = {
                  Name: name
                };
                ssm.deleteParameter(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    console.info(`Parameter: deleted`);
                    response.send(event, context, response.SUCCESS);
                  }
                });
            }
          };
    DependsOn: SecureParameterLogGroup
  MessageRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllowPublish
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: '*'
  MessageLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/Message
      RetentionInDays: !Ref MessageLogRetention
  MessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: Message
      Description: A Lambda function that publishes a message to an SNS Topic.
      Role: !GetAtt MessageRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('./cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            sns: '2010-03-31'
          };

          const sns = new AWS.SNS();

          exports.handler = (event, context) => {
            console.info(`Request Body:\n${JSON.stringify(event)}`);

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                const topicArn = event.ResourceProperties.TopicArn;
                if (! topicArn) {
                  const responseData = {Error: `Error: TopicArn missing`};
                  console.error(responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                const message = event.ResourceProperties.Message;
                if (! message) {
                  const responseData = {Error: `Error: Message missing`};
                  console.error(responseData.Error);
                  response.send(event, context, response.FAILED, responseData);
                  return;
                }

                console.info(`Calling: Publish...`);
                params = {
                  TopicArn: topicArn,
                  Message: message
                };
                sns.publish(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const messageId = data.MessageId;
                    console.info(`Message: ${messageId} sent`);
                    response.send(event, context, response.SUCCESS, null, messageId);
                  }
                });
                break;

              case 'Delete':
                response.send(event, context, response.SUCCESS);
            }
          };
    DependsOn: MessageLogGroup
  PrivateIpAddressRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DescribeSubnetsPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSubnets
                Resource: '*'
  PrivateIpAddressLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/PrivateIpAddress
      RetentionInDays: !Ref PrivateIpAddressLogRetention
  PrivateIpAddressFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: PrivateIpAddress
      Description: A Lambda function which calculates a PrivateIpAddress as an Offset into a VPC Subnet, based on the Subnet CIDR obtained via a Subnet ID.
      Role: !GetAtt PrivateIpAddressRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            ec2: '2016-11-15'
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const region = event.ResourceProperties.Region || process.env.AWS_REGION;
                  if (region != process.env.AWS_REGION) AWS.config.update({region: region});

                  const subnetId = event.ResourceProperties.SubnetId;
                  if (! /^subnet-[0-9a-f]{17}$/.test(subnetId)) {
                    throw new Error(`SubnetId invalid: must be valid Subnet ID`);
                  }

                  const offset = (event.ResourceProperties.Offset) ? Number(event.ResourceProperties.Offset) : 'invalid';
                  if (! Number.isInteger(offset) || offset < 0) {
                    throw new Error(`Offset invalid: must be a positive integer`);
                  }

                  const ec2 = new AWS.EC2();

                  console.info(`Calling: DescribeSubnets...`);
                  const params = {
                    Filters: [{ Name: 'subnet-id', Values: [subnetId]}]
                  };
                  const data = await ec2.describeSubnets(params).promise();

                  if (data.Subnets.length > 0) {
                    const subnetCidrBlock = data.Subnets[0].CidrBlock;
                    console.info(`Subnet: ${subnetId} = ${subnetCidrBlock}`);
                    const subnetAddress = subnetCidrBlock.split('/')[0];
                    const subnetNetmask = subnetCidrBlock.split('/')[1];
                    const subnetOctets = subnetAddress.split('.');
                    const subnetDecimal = ((((((+subnetOctets[0]) * 256) + (+subnetOctets[1])) * 256) + (+subnetOctets[2])) * 256) + (+subnetOctets[3]);

                    const loAddressDecimal = subnetDecimal + 4;
                    const loAddress = (loAddressDecimal >>> 24)       + '.'
                                    + (loAddressDecimal >>  16 & 255) + '.'
                                    + (loAddressDecimal >>   8 & 255) + '.'
                                    + (loAddressDecimal        & 255);
                    const hiAddressDecimal = subnetDecimal + Math.pow(2, 32 - subnetNetmask) - 2;
                    const hiAddress = (hiAddressDecimal >>> 24)       + '.'
                                    + (hiAddressDecimal >>  16 & 255) + '.'
                                    + (hiAddressDecimal >>   8 & 255) + '.'
                                    + (hiAddressDecimal        & 255);
                    console.info(`Subnet usable IP Address range: ${loAddress}-${hiAddress}`);

                    if (offset < 4 || offset > Math.pow(2, 32 - subnetNetmask) - 2) {
                      throw new Error(`Offset invalid: must be >= 4 and <= ${Math.pow(2, 32 - subnetNetmask) - 2} for this Subnet`);
                    }

                    const addressDecimal = subnetDecimal + offset;
                    const address = (addressDecimal >>> 24)       + '.'
                                  + (addressDecimal >>  16 & 255) + '.'
                                  + (addressDecimal >>   8 & 255) + '.'
                                  + (addressDecimal        & 255);
                    console.info(`Private IP Address: ${address}`);

                    await response.send(event, context, response.SUCCESS, {}, address);
                  }
                  else {
                    throw new Error(`Could not find ${subnetId} Subnet`);
                  }
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
            }
          };
    DependsOn: PrivateIpAddressLogGroup
  KeyPairRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: KeyPairPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowManageKeyPairs
                Effect: Allow
                Action:
                  - ec2:DescribeKeyPairs
                  - ec2:ImportKeyPair
                  - ec2:DeleteKeyPair
                Resource: '*'
  KeyPairLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/KeyPair
      RetentionInDays: !Ref KeyPairLogRetention
  KeyPairFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: KeyPair
      Description: A Lambda function that uses an external SSH Public Key to import an EC2 KeyPair.
      Role: !GetAtt KeyPairRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            ec2: '2016-11-15'
          };

          const ec2 = new AWS.EC2();

          const getKeyPair = async (keyName) => {
            console.info(`Calling: DescribeKeyPairs for Key ${keyName}...`);
            const params = {
              Filters: [{ Name: 'key-name', Values: [keyName] }]
            };
            return await ec2.describeKeyPairs(params).promise().then(data => data.KeyPairs[0]);
          };

          const importKeyPair = async (keyName, publicKeyMaterial) => {
            console.info(`Calling: ImportKeyPair for Key ${keyName}...`);
            const params = {
              KeyName: keyName,
              PublicKeyMaterial: publicKeyMaterial
            };
            return await ec2.importKeyPair(params).promise().then(data => data.KeyFingerprint);
          };

          const deleteKeyPair = async (keyName) => {
            console.info(`Calling: DeleteKeyPair for Key ${keyName}...`);
            const params = {
              KeyName: keyName
            };
            await ec2.deleteKeyPair(params).promise();
          };

          exports.handler = async (event, context) => {
            console.info(`Event:\n${JSON.stringify(event)}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const keyName = event.ResourceProperties.KeyName;
                  if (! /^[a-z][a-z0-9]{3,63}$/.test(keyName)) {
                    throw new Error(`KeyName invalid: must be a 4 - 64-character string which starts with a lower-case letter and consists of lower-case letters and digits`);
                  }

                  const publicKey = event.ResourceProperties.PublicKey;
                  if (! /^ssh-rsa AAAAB3NzaC1yc2E[=/+A-Za-z0-9]{701}( .*)?$/.test(publicKey)) {
                    throw new Error(`PublicKey invalid: Key is not in valid OpenSSH public key format`);
                  }

                  console.info(`KeyName: ${keyName}`);
                  console.info(`PublicKey: ${publicKey}`);

                  const keyPair = await getKeyPair(keyName);

                  if (keyPair) {
                    await deleteKeyPair(keyName);
                  }

                  const fingerprint = await importKeyPair(keyName, publicKey);
                  const responseData = {Fingerprint: fingerprint};
                  console.info(`KeyPair: ${keyName} with fingerprint ${fingerprint} ${(keyPair) ? 'created' : 'updated'}`);
                  await response.send(event, context, response.SUCCESS, responseData, keyName);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                try {
                  const keyName = event.ResourceProperties.KeyName;
                  if (! /^[a-z][a-z0-9]{3,63}$/.test(keyName)) {
                    throw new Error(`KeyName invalid: must be a 4 - 64-character string which starts with a lower-case letter and consists of lower-case letters and digits`);
                  }

                  const keyPair = await getKeyPair(keyName);

                  if (keyPair) {
                    const fingerprint = keyPair.KeyFingerprint;
                    await deleteKeyPair(keyName);
                    console.info(`KeyPair: ${keyName} with fingerprint ${fingerprint} deleted`);
                  }
                  else {
                    console.info(`KeyPair: ${keyName} not found`);
                  }
                  await response.send(event, context, response.SUCCESS);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
            }
          };
    DependsOn: KeyPairLogGroup
  IdentifierRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ReadDynamoDBCodesTable
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowGetItem
                Effect: Allow
                Action:
                  - dynamodb:Get*
                Resource: !Sub
                  - arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${Table}
                  - Table: !ImportValue
                      Fn::Sub: ${CodesStackName}-Table
  AMINameLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/AMIName
      RetentionInDays: !Ref AMINameLogRetention
  AMINameFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AMIName
      Description: A Lambda function which creates an AMIName that conforms to CaMeLz Framework Naming Conventions.
      Role: !GetAtt IdentifierRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            dynamodb: '2012-08-10'
          };

          const dynamodb = new AWS.DynamoDB();

          const getCode = async (tableName, type, name) => {
            console.info(`- Calling: GetItem for Type ${type}, Name ${name}...`);
            const params = {
              TableName: tableName,
              Key: { Type: { S: type }, Name: { S: name }},
              AttributesToGet: [ 'Code' ]
            };
            const data = await dynamodb.getItem(params).promise();
            if (data.Item && data.Item.Code) {
              return data.Item.Code.S;
            }
            else {
              throw new Error(`Code for Name ${name} of Type ${type} not found`);
            }
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const tableName = event.ResourceProperties.TableName || 'Codes';

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const companyName = event.ResourceProperties.CompanyName;
                  const companySegment = (companyName) ? `/${await getCode(tableName, 'Company', companyName)}` : '';

                  const systemName = event.ResourceProperties.SystemName;
                  const systemSegment = (systemName) ? `/${await getCode(tableName, 'System', systemName)}` : '';

                  const serviceName = event.ResourceProperties.ServiceName;
                  const serviceSegment = (serviceName) ? `/${serviceName}` : '';

                  const applicationName = event.ResourceProperties.ApplicationName;
                  const applicationSegment = (applicationName) ? `/${applicationName}` : '';

                  const environmentName = event.ResourceProperties.EnvironmentName;
                  const environmentSegment = (environmentName) ? `/${environmentName}` : '';

                  const aliasname = `${companySegment}${systemSegment}${serviceSegment}${applicationSegment}${environmentSegment}`.substring(1);
                  console.info('AliasName: ' + aliasname);
                  await response.send(event, context, response.SUCCESS, null, aliasname);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
                break;
            }
          };
    DependsOn: AMINameLogGroup
  AliasNameLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/AliasName
      RetentionInDays: !Ref AliasNameLogRetention
  AliasNameFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AliasName
      Description: A Lambda function which creates an AliasName that conforms to CaMeLz Framework Naming Conventions.
      Role: !GetAtt IdentifierRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            dynamodb: '2012-08-10'
          };

          const dynamodb = new AWS.DynamoDB();

          const getCode = async (tableName, type, name) => {
            console.info(`- Calling: GetItem for Type ${type}, Name ${name}...`);
            const params = {
              TableName: tableName,
              Key: { Type: { S: type }, Name: { S: name }},
              AttributesToGet: [ 'Code' ]
            };
            const data = await dynamodb.getItem(params).promise();
            if (data.Item && data.Item.Code) {
              return data.Item.Code.S;
            }
            else {
              throw new Error(`Code for Name ${name} of Type ${type} not found`);
            }
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const tableName = event.ResourceProperties.TableName || 'Codes';

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const companyName = event.ResourceProperties.CompanyName;
                  const companySegment = (companyName) ? `/${await getCode(tableName, 'Company', companyName)}` : '';

                  const systemName = event.ResourceProperties.SystemName;
                  const systemSegment = (systemName) ? `/${await getCode(tableName, 'System', systemName)}` : '';

                  const serviceName = event.ResourceProperties.ServiceName;
                  const serviceSegment = (serviceName) ? `/${serviceName}` : '';

                  const applicationName = event.ResourceProperties.ApplicationName;
                  const applicationSegment = (applicationName) ? `/${applicationName}` : '';

                  const environmentName = event.ResourceProperties.EnvironmentName;
                  const environmentSegment = (environmentName) ? `/${environmentName}` : '';

                  const aliasname = `${companySegment}${systemSegment}${serviceSegment}${applicationSegment}${environmentSegment}`.substring(1);
                  console.info('AliasName: ' + aliasname);
                  await response.send(event, context, response.SUCCESS, null, aliasname);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
                break;
            }
          };
    DependsOn: AliasNameLogGroup
  LogGroupNameLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/LogGroupName
      RetentionInDays: !Ref LogGroupNameLogRetention
  LogGroupNameFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: LogGroupName
      Description: A Lambda function which creates a LogGroupName that conforms to CaMeLz Framework Naming Conventions.
      Role: !GetAtt IdentifierRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            dynamodb: '2012-08-10'
          };

          const dynamodb = new AWS.DynamoDB();

          const getCode = async (tableName, type, name) => {
            console.info(`- Calling: GetItem for Type ${type}, Name ${name}...`);
            const params = {
              TableName: tableName,
              Key: { Type: { S: type }, Name: { S: name }},
              AttributesToGet: [ 'Code' ]
            };
            const data = await dynamodb.getItem(params).promise();
            if (data.Item && data.Item.Code) {
              return data.Item.Code.S;
            }
            else {
              throw new Error(`Code for Name ${name} of Type ${type} not found`);
            }
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const tableName = event.ResourceProperties.TableName || 'Codes';

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const companyName = event.ResourceProperties.CompanyName;
                  const companySegment = (companyName) ? `/${await getCode(tableName, 'Company', companyName)}` : '';

                  const systemName = event.ResourceProperties.SystemName;
                  const systemSegment = (systemName) ? `/${await getCode(tableName, 'System', systemName)}` : '';

                  const applicationName = event.ResourceProperties.ApplicationName;
                  const applicationSegment = (applicationName) ? `/${applicationName}` : '';

                  const componentName = event.ResourceProperties.ComponentName;
                  const componentSegment = (componentName) ? `-${componentName}` : '';

                  const environmentName = event.ResourceProperties.EnvironmentName;
                  const environmentSegment = (environmentName) ? `/${environmentName}` : '';

                  const loggroupname = `${companySegment}${systemSegment}${applicationSegment}${componentSegment}${environmentSegment}`;
                  console.info('LogGroupName: ' + loggroupname);
                  await response.send(event, context, response.SUCCESS, null, loggroupname);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
                break;
            }
          };
    DependsOn: LogGroupNameLogGroup
  HostNameLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/HostName
      RetentionInDays: !Ref HostNameLogRetention
  HostNameFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: HostName
      Description: A Lambda function which creates a HostName that conforms to CaMeLz Framework Naming Conventions.
      Role: !GetAtt IdentifierRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            dynamodb: '2012-08-10'
          };

          const dynamodb = new AWS.DynamoDB();

          const getCode = async (tableName, type, name) => {
            console.info(`- Calling: GetItem for Type ${type}, Name ${name}...`);
            const params = {
              TableName: tableName,
              Key: { Type: { S: type }, Name: { S: name }},
              AttributesToGet: [ 'Code' ]
            };
            const data = await dynamodb.getItem(params).promise();
            if (data.Item && data.Item.Code) {
              return data.Item.Code.S;
            }
            else {
              throw new Error(`Code for Name ${name} of Type ${type} not found`);
            }
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const tableName = event.ResourceProperties.TableName || 'Codes';

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const companyName = event.ResourceProperties.CompanyName;
                  const companyCode = (companyName) ? await getCode(tableName, 'Company', companyName) : '';

                  const locationName = event.ResourceProperties.LocationName || process.env.AWS_REGION;
                  const locationCode = (locationName) ? await getCode(tableName, 'Location', locationName) : '';

                  const environmentName = event.ResourceProperties.EnvironmentName;
                  const environmentCode = (environmentName) ? await getCode(tableName, 'Environment', environmentName) : '';

                  const systemName = event.ResourceProperties.SystemName;
                  const systemCode = (systemName) ? await getCode(tableName, 'System', systemName) : '';

                  const applicationName = event.ResourceProperties.ApplicationName;
                  const applicationCode = (applicationName) ? await getCode(tableName, 'Application', applicationName) : '';

                  const componentName = event.ResourceProperties.ComponentName;
                  const componentCode = (componentName) ? await getCode(tableName, 'Component', componentName) : '';

                  let instanceNumber = event.ResourceProperties.InstanceNumber || '';
                  if (instanceNumber) {
                    if (/^(0?[1-9]|[1-9][0-9])$/.test(instanceNumber)) {
                      instanceNumber = instanceNumber.padStart(2, '0');
                    }
                    else {
                      throw new Error(`InstanceNumber invalid`);
                    }
                  }

                  const zoneCode = event.ResourceProperties.ZoneCode || '';
                  if (zoneCode && ! /^[a-f]$/.test(zoneCode)) {
                    throw new Error(`ZoneCode invalid`);
                  }

                  const hostname = `${companyCode}${locationCode}${environmentCode}${systemCode}${applicationCode}${componentCode}${instanceNumber}${zoneCode}`;
                  console.info('HostName: ' + hostname);
                  await response.send(event, context, response.SUCCESS, null, hostname);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
                break;
            }
          };
    DependsOn: HostNameLogGroup
  DomainNameLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/lambda/DomainName
      RetentionInDays: !Ref DomainNameLogRetention
  DomainNameFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: DomainName
      Description: A Lambda function which creates a DomainName that conforms to CaMeLz Framework Naming Conventions.
      Role: !GetAtt IdentifierRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !ImportValue
            Fn::Sub: ${LayersStackName}-AsyncCustomResourceLayerVersionArn
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            dynamodb: '2012-08-10'
          };

          const dynamodb = new AWS.DynamoDB();

          const getCode = async (tableName, type, name) => {
            console.info(`- Calling: GetItem for Type ${type}, Name ${name}...`);
            const params = {
              TableName: tableName,
              Key: { Type: { S: type }, Name: { S: name }},
              AttributesToGet: [ 'Code' ]
            };
            const data = await dynamodb.getItem(params).promise();
            if (data.Item && data.Item.Code) {
              return data.Item.Code.S;
            }
            else {
              throw new Error(`Code for Name ${name} of Type ${type} not found`);
            }
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const tableName = event.ResourceProperties.TableName || 'Codes';

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                try {
                  const parentDomainName = event.ResourceProperties.ParentDomainName;
                  if (! /^([A-Za-z0-9][A-Za-z0-9-]{0,61}[A-Za-z0-9]?\.)+[A-Za-z]{2,10}$/.test(parentDomainName)) {
                    throw new Error(`ParentDomainName missing or invalid`);
                  }

                  const locationName = event.ResourceProperties.LocationName || process.env.AWS_REGION;
                  if (! /^(us-east-1|us-east-2|us-west-1|us-west-2|ca-central-1|eu-west-1|eu-central-1|eu-west-2|eu-west-3|eu-north-1|ap-east-1|ap-southeast-1|ap-southeast-2|ap-northeast-2|ap-northeast-1|ap-south-1|me-south-1|sa-east-1)$/.test(locationName)) {
                    throw new Error(`LocationName invalid: Must be an AWS Region code`);
                  }

                  const environmentName = event.ResourceProperties.EnvironmentName;
                  const environmentCode = (environmentName) ? await getCode(tableName, 'Environment', environmentName) : '';

                  const domainname = `${(environmentCode == 'p') ? '' : environmentCode + '.'}${locationName}.${parentDomainName}`;
                  console.info('DomainName: ' + domainname);
                  await response.send(event, context, response.SUCCESS, null, domainname);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
                break;

              case 'Delete':
                await response.send(event, context, response.SUCCESS);
                break;
            }
          };
    DependsOn: DomainNameLogGroup
Outputs:
  BucketManagerFunctionArn:
    Description: The BucketManager Lambda Function ARN
    Value: !GetAtt BucketManagerFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-BucketManagerFunctionArn
  RandomPasswordFunctionArn:
    Description: The RandomPassword Lambda Function ARN
    Value: !GetAtt RandomPasswordFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-RandomPasswordFunctionArn
  SecureParameterFunctionArn:
    Description: The SecureParameter Lambda Function ARN
    Value: !GetAtt SecureParameterFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-SecureParameterFunctionArn
  MessageFunctionArn:
    Description: The Message Lambda Function ARN
    Value: !GetAtt MessageFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-MessageFunctionArn
  PrivateIpAddressFunctionArn:
    Description: The PrivateIpAddress Lambda Function ARN
    Value: !GetAtt PrivateIpAddressFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-PrivateIpAddressFunctionArn
  KeyPairFunctionArn:
    Description: The KeyPair Lambda Function ARN
    Value: !GetAtt KeyPairFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-KeyPairFunctionArn
  AMINameFunctionArn:
    Description: The AMIName Lambda Function ARN
    Value: !GetAtt AMINameFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-AMINameFunctionArn
  AliasNameFunctionArn:
    Description: The AliasName Lambda Function ARN
    Value: !GetAtt AliasNameFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-AliasNameFunctionArn
  LogGroupNameFunctionArn:
    Description: The LogGroupName Lambda Function ARN
    Value: !GetAtt LogGroupNameFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-LogGroupNameFunctionArn
  HostNameFunctionArn:
    Description: The HostName Lambda Function ARN
    Value: !GetAtt HostNameFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-HostNameFunctionArn
  DomainNameFunctionArn:
    Description: The DomainName Lambda Function ARN
    Value: !GetAtt DomainNameFunction.Arn
    Export:
      Name: !Sub ${AWS::StackName}-DomainNameFunctionArn
