AWSTemplateFormatVersion: 2010-09-09
Description: Buckets Template.
  This creates S3 Buckets which should exist in every Region. These buckets hold artifacts needed to build Stacks.
  # This Template has an "Unpublished" dependency on the Functions Stack, when Bucket Managers are desired to empty and
  # remove buckets on Stack deletion. The Functions Stack depends on the Layers Stack, and both depend on this Buckets
  # Stack to store Layer and Function Package Zip Files. As a result, a two-part build sequence is required. This Stack
  # must be created with the Bootstrap Parameter set to true, then content must be loaded, then the Layers and Functions
  # Stacks are created next, then this Stack should be updated with the Bootstrap Parameter set to false.
  # Unlike all other Stacks, where we use explicit <Resource>StackName Parameters to indicate when a Stack depends on
  # another Stack, we can not use that method here, as that would create a circular dependency on the Functions Stack
  # as soon as we Imported a value using that reference, preventing the deletion of that Stack. we can not publish a FunctionsStackName Parameter and then use this to import the BucketManagerFunction
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Layer Configuration
        Parameters:
          - BootstrapAsyncCustomResourceLayerEncodedContent
      - Label:
          default: Environment Configuration
        Parameters:
          - AccountAlias
          - EnvironmentName
      - Label:
          default: Bucket Configuration
        Parameters:
          - UseBucketManagers
          - DeletionPolicy
    ParameterLabels:
      BootstrapAsyncCustomResourceLayerEncodedContent:
        default: Bootstrap AsyncCustomResource Layer Encoded Content
      AccountAlias:
        default: Account Alias
      EnvironmentName:
        default: Environment Name
      UseBucketManagers:
        default: Use Bucket Managers
      DeletionPolicy:
        default: Deletion Policy
Parameters:
  BootstrapAsyncCustomResourceLayerEncodedContent:
    Description: Content of the BootstrapAsyncCustomResource Layer as a Base64-encoded string (Default is AsyncCustomResourceLayer.zip)
    Type: String
    Default: "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\
      AFBLBQYAAAAABAAEAI0BAADUBAAAAAA="
    ConstraintDescription: must be a Base64-encrypted string, containing the Layer archive content.
  AccountAlias:
    Description: Unique Alias of the Account (if defined). If specified, the Alias instead of the AccountID is appended to bucket names to insure uniqueness.
    Type: String
    MaxLength: 32
    Default: ''
    AllowedPattern: (^$|^[a-z][-a-z0-9]*$)
    ConstraintDescription: must begin with a lower case letter and contain lower case letters, numbers and dashes.
  EnvironmentName:
    Description: Name of the Environment associated with the Stack
    Type: String
    Default: Production
    AllowedValues:
      - Organization
      - Jumpstart
      - Management
      - Core
      - Log
      - Build
      - Production
      - NonProduction
      - Recovery
      - Staging
      - UAT
      - QA
      - Testing
      - Development
    ConstraintDescription: must be Organization, Jumpstart, Management, Core, Log, Build, Production, NonProduction, Recovery, Staging, UAT, QA, Testing or Development.
  UseBucketManagers:
    Description: Use Bucket Managers (Allows Delete or Retain Buckets on Stack Deletion)
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
    ConstraintDescription: must be either true or false.
  DeletionPolicy:
    Description: Delete or Retain Buckets on Stack Deletion
    Type: String
    Default: Delete
    AllowedValues:
      - Delete
      - Retain
    ConstraintDescription: must be Delete or Retain.
Conditions:
  AppendAccountId: !Equals [ !Ref AccountAlias, '' ]
  ConfigureBucketManagers: !Equals [ !Ref UseBucketManagers, true ]
  EmptyAndDeleteBuckets: !Equals [ !Ref DeletionPolicy, Delete ]
Resources:
  BootstrapEncodedLayerVersionRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageLambdaLayers
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: ListLayers
                Effect: Allow
                Action:
                  - lambda:ListLayerVersions
                Resource: '*'
              - Sid: PublishLayers
                Effect: Allow
                Action:
                  - lambda:PublishLayerVersion
                Resource: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:BootstrapAsyncCustomResource*
              - Sid: ManageLayerVersions
                Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                  - lambda:DeleteLayerVersion
                Resource: !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:BootstrapAsyncCustomResource*:*
  BootstrapEncodedLayerVersionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BootstrapEncodedLayerVersion
      Description: A Lambda function which creates a Lambda LayerVersion from Base64-encoded Content.
      Role: !GetAtt BootstrapEncodedLayerVersionRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('./cfn-response');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            lambda: '2015-03-31'
          };

          const lambda = new AWS.Lambda();

          exports.handler = (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            const layerName = event.ResourceProperties.LayerName;
            if (! layerName) {
              const responseData = {Error: `Error: LayerName missing`};
              console.error(responseData.Error);
              response.send(event, context, response.FAILED, responseData);
              return;
            }
            const content = event.ResourceProperties.Content.replace(/ /g, '');
            if (! content && event.RequestType != 'Delete') {
              const responseData = {Error: `Error: Content missing`};
              console.error(responseData.Error);
              response.send(event, context, response.FAILED, responseData);
              return;
            }

            let params = {};
            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                console.info(`Calling: PublishLayerVersion...`);
                params = {
                  LayerName: layerName,
                  Content: {
                    ZipFile: Buffer.from(content, 'base64')
                  }
                };
                if (event.ResourceProperties.Description) params.Description = event.ResourceProperties.Description;
                if (event.ResourceProperties.LicenseInfo) params.LicenseInfo = event.ResourceProperties.LicenseInfo;
                if (event.ResourceProperties.CompatibleRuntimes) params.CompatibleRuntimes = event.ResourceProperties.CompatibleRuntimes;
                lambda.publishLayerVersion(params, (err, data) => {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const layerVersionArn = data.LayerVersionArn;
                    const codeSha256 = data.Content.CodeSha256;
                    const responseData = {CodeSha256: codeSha256};
                    console.info(`LayerVersion: ${layerVersionArn} created, Code SHA-256: ${codeSha256}`);
                    response.send(event, context, response.SUCCESS, responseData, layerVersionArn, false);
                  }
                });
                break;

              case 'Delete':
                console.info(`Calling: ListLayerVersions...`);
                  params = {
                    LayerName: layerName
                  };
                  lambda.listLayerVersions(params, function(err, data) {
                  if (err) {
                    const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                    console.error(responseData.Error);
                    response.send(event, context, response.FAILED, responseData);
                  }
                  else {
                    const layerVersions = data.LayerVersions.map(lv => lv.Version);
                    let deletePromises = [];
                    for (const layerVersion of layerVersions) {
                      params = {
                        LayerName: layerName,
                        VersionNumber: layerVersion
                      };
                      deletePromises.push(lambda.deleteLayerVersion(params).promise());
                    }
                    console.info(`Waiting for ${deletePromises.length} DeleteLayerVersion calls to finish...`);
                    Promise.all(deletePromises).then(results => {
                      console.info('LayerVersions deleted');
                      response.send(event, context, response.SUCCESS);
                    }).catch(err => {
                      const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                      console.error(responseData.Error);
                      response.send(event, context, response.FAILED, responseData);
                    });
                  }
                });
            }
          };
  BootstrapAsyncCustomResourceLayerVersion:
    Type: Custom::BootstrapEncodedLayerVersion
    Properties:
      ServiceToken: !GetAtt BootstrapEncodedLayerVersionFunction.Arn
      LayerName: BootstrapAsyncCustomResource
      Description: A Lambda layer version which contains the cfn-response-promise module, needed to write Lambda
        Functions which use the async/await coding style instead of callbacks.
      LicenseInfo: MIT
      CompatibleRuntimes:
        - nodejs10.x
        - nodejs12.x
      Content: !Ref BootstrapAsyncCustomResourceLayerEncodedContent
  BootstrapBucketManagerRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ManageBuckets
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - s3:*
                Resource: !Sub
                  - arn:aws:s3:::*-${Account}-${AWS::Region}
                  - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
              - Effect: Allow
                Action:
                  - s3:*
                Resource: !Sub
                  - arn:aws:s3:::*-${Account}-${AWS::Region}/*
                  - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
  BootstrapBucketManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: BootstrapBucketManager
      Description: A Lambda function that manages content in an S3 Bucket.
      Role: !GetAtt BootstrapBucketManagerRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
      Layers:
        - !Ref BootstrapAsyncCustomResourceLayerVersion
      Handler: index.handler
      Code:
        ZipFile: |
          const response = require('cfn-response-promise');

          const AWS = require('aws-sdk');
          AWS.config.apiVersions = {
            s3: '2006-03-01'
          };

          const s3 = new AWS.S3();

          const emptyBucket = async (bucketName) => {
            const listParams = {
              Bucket: bucketName
            };
            let listData = {};
            do {
              listData = await s3.listObjectVersions(listParams).promise();
              //console.info(`- listObjectVersions Data:\n${JSON.stringify(listData, null, 2)}`);

              if (listData.Versions.length > 0) {
                const deleteParams = {
                  Bucket: bucketName,
                  Delete: {
                    Objects: listData.Versions.map(v => ({Key: v.Key, VersionId: v.VersionId}))
                  }
                };
                const deleting = deleteParams.Delete.Objects.length;
                const deleteData = await s3.deleteObjects(deleteParams).promise();
                const deleted = deleteData.Deleted.length;
                if (deleting == deleted) {
                  console.info(`- Deleted ${deleted} object versions`);
                }
                else {
                  console.info(`- deleteObjects Data:\n${JSON.stringify(deleteData, null, 2)}`);
                  throw new Error(`Could not delete ${deleting - deleted} object versions!`);
                }
              }

              if (listData.DeleteMarkers.length > 0) {
                const deleteParams = {
                  Bucket: bucketName,
                  Delete: {
                    Objects: listData.DeleteMarkers.map(dm => ({Key: dm.Key, VersionId: dm.VersionId}))
                  }
                };
                const deleting = deleteParams.Delete.Objects.length;
                const deleteData = await s3.deleteObjects(deleteParams).promise();
                const deleted = deleteData.Deleted.length;
                if (deleting == deleted) {
                  console.info(`- Deleted ${deleted} delete markers`);
                }
                else {
                  console.info(`- deleteObjects Data:\n${JSON.stringify(deleteData, null, 2)}`);
                  throw new Error(`Could not delete ${deleting - deleted} delete markers!`);
                }
              }

              if (listData.IsTruncated) {
                listParams.KeyMarker = listData.NextKeyMarker;
                listParams.VersionIdMarker = listData.NextVersionIdMarker;
              }
            } while (listData.IsTruncated);

            return;
          };

          const deleteBucket = async (bucketName) => {
            const params = {
              Bucket: bucketName
            };
            const data = await s3.deleteBucket(params).promise();
            //console.info(`- deleteBucket Data:\n${JSON.stringify(data, null, 2)}`);

            return;
          };

          exports.handler = async (event, context) => {
            console.info(`Request body:\n${JSON.stringify(event)}`);

            let bucketName;
            let emptyAndDeleteBucket;

            try {
              bucketName = event.ResourceProperties.BucketName;
              if (! bucketName) {
                throw new Error(`BucketName missing: required Parameter`);
              }

              emptyAndDeleteBucket = /^(t(rue)?|y(es)?|1|on)$/i.test(event.ResourceProperties.EmptyAndDeleteBucket || 'True');
            }
            catch (err) {
              const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
              console.error(responseData.Error);
              await response.send(event, context, response.FAILED, responseData);
            }

            console.info(`BucketName: ${bucketName}`);
            console.info(`EmptyAndDeleteBucket: ${emptyAndDeleteBucket}`);

            switch (event.RequestType) {
              case 'Create':
              case 'Update':
                await response.send(event, context, response.SUCCESS, {}, bucketName + '-manager');
                break;

              case 'Delete':
                try {
                  if (emptyAndDeleteBucket) {
                    console.info(`Calling: emptyBucket...`);
                    await emptyBucket(bucketName);

                    console.info(`Calling: deleteBucket...`);
                    await deleteBucket(bucketName);
                  }
                  await response.send(event, context, response.SUCCESS);
                }
                catch (err) {
                  const responseData = {Error: `${(err.code) ? err.code : 'Error'}: ${err.message}`};
                  console.error(responseData.Error);
                  await response.send(event, context, response.FAILED, responseData);
                }
            }
          };
  TemplatesBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - templates-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-TemplatesBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  TemplatesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TemplatesBucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: AllowCloudFormationACLCheck
            Effect: Allow
            Principal:
              Service: cloudformation.amazonaws.com
            Action: s3:GetBucketAcl
            Resource: !Sub arn:aws:s3:::${TemplatesBucket}
          - Sid: AllowCloudFormationRead
            Effect: Allow
            Principal:
              Service: cloudformation.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${TemplatesBucket}/*
    DependsOn: TemplatesBucket
  TemplatesBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref TemplatesBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  FunctionsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - functions-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-FunctionsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  FunctionsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref FunctionsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  DocumentsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - documents-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-DocumentsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  DocumentsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref DocumentsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  ScriptsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - scripts-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-ScriptsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  ScriptsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref ScriptsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  ConfigurationsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - configurations-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-ConfigurationsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  ConfigurationsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref ConfigurationsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  ProductsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - products-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-ProductsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  ProductsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref ProductsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
  BackupsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub
        - backups-${Account}-${AWS::Region}
        - Account: !If [ AppendAccountId, !Ref 'AWS::AccountId', !Ref AccountAlias ]
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - Id: ReduceStorageCostsThenDeletePriorVersions
            Status: Enabled
            Prefix: ''
            Transitions:
              - StorageClass: GLACIER
                TransitionInDays: 90
            ExpirationInDays: 365
            NoncurrentVersionTransitions:
              - StorageClass: GLACIER
                TransitionInDays: 30
            NoncurrentVersionExpirationInDays: 180
      Tags:
        - Key: Name
          Value: !Sub ${EnvironmentName}-BackupsBucket
    DeletionPolicy: Retain # We can't reference a Parameter here - Delete performed by Bucket Managers
  BackupsBucketManager:
    Type: Custom::BucketManager
    Properties:
      ServiceToken: !GetAtt BootstrapBucketManagerFunction.Arn
      BucketName: !Ref BackupsBucket
      EmptyAndDeleteBucket: !If [ EmptyAndDeleteBuckets, True, 'AWS::NoValue' ]
    Condition: ConfigureBucketManagers
Outputs:
  TemplatesBucket:
    Description: The Templates Bucket Name
    Value: !Ref TemplatesBucket
    Export:
      Name: !Sub ${AWS::StackName}-TemplatesBucket
  FunctionsBucket:
    Description: The Functions Bucket Name
    Value: !Ref FunctionsBucket
    Export:
      Name: !Sub ${AWS::StackName}-FunctionsBucket
  DocumentsBucket:
    Description: The Documents Bucket Name
    Value: !Ref DocumentsBucket
    Export:
      Name: !Sub ${AWS::StackName}-DocumentsBucket
  ScriptsBucket:
    Description: The Scripts Bucket Name
    Value: !Ref ScriptsBucket
    Export:
      Name: !Sub ${AWS::StackName}-ScriptsBucket
  ConfigurationsBucket:
    Description: The Configurations Bucket Name
    Value: !Ref ConfigurationsBucket
    Export:
      Name: !Sub ${AWS::StackName}-ConfigurationsBucket
  ProductsBucket:
    Description: The Products Bucket Name
    Value: !Ref ProductsBucket
    Export:
      Name: !Sub ${AWS::StackName}-ProductsBucket
  BackupsBucket:
    Description: The Backups Bucket Name
    Value: !Ref BackupsBucket
    Export:
      Name: !Sub ${AWS::StackName}-BackupsBucket
